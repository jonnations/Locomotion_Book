---
title: "Ordinal Classification"
output:
  html_document:
    df_print: paged
---

# Missing Data Models
Re-doing the Ordinal_2 script but by estimating the missing values in the datasets. 


Same as `Ordinal_Models.Rmd` but with 4 categories:  

- Arboreal (arboreal and gliding)  
- Scansorial  
- Terrestrial  
- Burrowing (inter-substrate, semi-fossorial, substrate submerged?)

Models will also incorporate intraspecific variation and phylogenetic variation.


## Preparation  

### Load packages and functions  
```{r message = FALSE, warning=FALSE, include = FALSE}

pacman::p_load(tidyverse, googlesheets4, brms, cmdstanr, kableExtra, here, ape, tidybayes, patchwork, glue)

options(brms.backend = "cmdstanr")

scale2 <- function(x, na.rm = TRUE) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm)

here::i_am("README.md")
here()
```

### Load data  
### Load data  
```{r message = FALSE, warning=FALSE}
dat <- read_sheet("https://docs.google.com/spreadsheets/d/1-eknhyZ1JNnXqhg2kViyzVntC8NGZvILQX-aQQb1Jvk/edit#gid=325036460", na = c("NA", "?", "")) %>%
  select(!NOTES) %>% 
# Recode Ordinal Rankings
  mutate(Loc_Ord = case_when(Loc_mode_Ordinal == "G"  ~ "G",
                             Loc_mode_Ordinal == "A"  ~ "A",
                             Loc_mode_Ordinal == "Sc" ~ "Sc",
                             Loc_mode_Ordinal == "T"  ~ "T",
                             Loc_mode_Ordinal == "Is" ~ "Is",
                             Loc_mode_Ordinal == "Sf" ~ "Sf",
                             Loc_mode_Ordinal == "Ss" ~ "Ss",
                             TRUE ~ NA),
         Loc_Ord = as.ordered(Loc_Ord),
         Loc_Ord = fct_relevel(Loc_Ord, c("G","A","Sc","T","Is","Sf","Ss")),
         # Combining the Intersurface and Semifossorial
         Loc_Ord2 = case_when(Loc_mode_Ordinal == "G" ~ "A",
                              Loc_mode_Ordinal == "A" ~ "A",
                              Loc_mode_Ordinal == "Sc" ~ "Sc",
                              Loc_mode_Ordinal == "T" ~ "T",
                              Loc_mode_Ordinal == "Is" ~ "B",
                              Loc_mode_Ordinal == "Sf" ~ "B",
                              Loc_mode_Ordinal == "Ss" ~ "B",
                             TRUE ~ NA),
         Loc_Ord2 = as.ordered(Loc_Ord2),
         Loc_Ord2 = fct_relevel(Loc_Ord2, c("B","T","Sc","A")),
         Loc_bin = case_when(Loc_mode_Bindary == "Ground" ~ 0,
                             Loc_mode_Bindary == "Tree" ~ 1,
                             TRUE ~ NA
                             ),
        # Loc_bin = as.factor(Loc_bin),
         Loc_mode_Categorical = as.factor(Loc_mode_Categorical),
         log_Mass = log(Mass_grams)) %>% 
    relocate(Loc_bin, .after = Loc_mode_Bindary) %>% 
  relocate(Loc_Ord, .after = Loc_mode_Ordinal) %>% 
  relocate(Loc_Ord2, .after = Loc_Ord) %>%
  relocate(log_Mass, .before = Skl) %>% 
#################
#Calculate Indices!
#################
  mutate(SI = Sh / Sl,             # Scapular Index
         HRI = Hsw / Hl,           # Humeral Robustness Index
         HPI = Hpw / Hl,           # Humeral Proximal Index
         HEB = Hdw / Hl,           # Humeral Epicondyle Breadth
         HHRI = Hhl / Hl,          # Humeral Head Robustness Index
         HHW = Hhw / Hhl,          # Humeral Head Shape Index
         DI = Hdcw / Hsw,          # Deltopectoral Crest Index
         OLI = Uol / Ul,           # Olecranon Process Length Index
         BI = Rl / Hl,             # Brachial Index
         IM = (Hl+Ul)/(Fl+Tl),     # Intermembral Index
         PRTI = Mcl/(Hl+Rl),       # Palm Robustness Index
         MRI = Mcw / Mcl,          # Metacarpal Robustness
         MANUS = Ppl / Mcl,        # MANUS index
         MANUS2 = (Ppl+Ipl)/Mcl,   # MANUS index with intermed. phalanx
         IRI = Fgh / Fl,           # Gluteal Index
         FRI = Fsw / Fl,           # Femoral Robustness
         FEB = Fdw / Fl,           # Femoral Epicondyle Breadth
         CI = Tl / Fl,             # Crural Index
         TRI = Tmw / Tl,           # Tibial Robustness Index
         #ANR = Anl / Al,          # Astragular Neck Robustness Index
         #CAR = Cal / Cl,          # Calcaneal Robustness Index
         IRI = Il / Pel,           # Illium Robustness Index
         PR = Il / Isl,            # Pelvic Index
         PES = Pppl / Mtl,         # PES INdex
         PES2 = (Pppl+Pipl)/Mtl    # PES with intermediate Phalanx
         ) %>% 
    # geometric mean
  drop_na(Tmw, Fdw, Tl, Fl, Fsw , Sh, Sl, Hdw, Hl, Hsw, Rl, Ul, Uol) %>%
  mutate(gm = ( Tmw * Fdw * Tl * Fl * Fsw  * Sh * Sl * Hdw * Hl * Hsw * Rl * Ul * Uol)^(1/13)) %>%
  relocate(gm, .before = log_Mass) %>% 
  mutate_at(vars(19:73), log) %>% 
  mutate_at(vars(17:95), scale2)

spp_obs <- dat$Taxon_Upham_style %>% unique()

pal = c( '#62361B', '#e6ab02',  '#7570b3', '#66a61e')
```

### Load Tree & Get Cor Matrix

```{r}
tr <- ape::read.nexus(
  here("Data","MCC_Upham_all_mammals.nex"))
tr <- keep.tip(tr, spp_obs)
A <- ape::vcv.phylo(tr, corr = TRUE)
```

## Miss Lists  

The percentages are stored in the df `Missing_Data_Percents.csv`

***all variables with complete data:***
log_Mass, Sl, Sh, Hl, Hsw, Hdw, Uol, Ul, Rl, Fl, Fsw, Fdw, Tl, Tmw, SI, HRI, HEB, OLI, BI, IM, FRI, FEB, CI, TRI

***Linear measurements with complete data***
log_Mass, Sl, Sh, Hl, Hsw, Hdw, Uol, Ul, Rl, Fl, Fsw, Fdw, Tl, Tmw

***All variables with missing data:***
Pdpw, Dpw, Pipw, Pdpl, Cal, Anl, Atw, Csw, Ccw, Ctl, Ctw, Al, Jl, Ipw, Dpl, Pppw, Skl, Mtw, Fbdw, Fhd, Fgh, Fbmw, Hhw, Hhl, HHRI, HHW, Cl, Fbpw, Pipl, PES2, Ppw, Mcw, MRI, Hpw, Pel, Il, Isl, Tpw, Fbl, HPI, IRI, PR, Hdcw, DI, Tdw, Ipl, MANUS2, Pppl, PES, Mtl, Ppl, MANUS, Mcl, PRTI

***Linear measurements with missing data:***
Pdpw, Dpw, Pipw, Pdpl, Cal, Anl, Atw, Csw, Ccw, Ctl, Ctw, Al, Jl, Ipw, Dpl, Pppw, Skl, Mtw, Fbdw, Fhd, Fgh, Fbmw, Hhw, Hhl, Cl, Fbpw, Pipl, Ppw, Mcw, Hpw, Pel, Il, Isl, Tpw, Fbl, Hdcw, Tdw, Ipl, Pppl, Mtl, Ppl, Mcl


Will also need to estimate the geometric mean for some species. 

# Missing Data Model Test
 Ignore the geometric mean for now, let's start with the log mass and a linear measurement that fairs pretty well.


## Test 1: 30% 
**Ipl** or intermediate phalanx length -> roughly 30% missing data

#### Formula:  
This is complicated because I have to estimate the missing values with a gaussian model, then estimate the ordinal model. See post #3 [here:](https://discourse.mc-stan.org/t/error-argument-mi-is-not-supported-for-family-bernoulli-logit/7587/3)

I assume these models are going to take a while. My poor computer has started running the fan whenever I run 4 cores. 
```{r}
ord_mod <-  
  bf(Loc_Ord2 ~ mi(Ipl) + log_Mass + 
       (1 | Genus_species) +  
       (1|gr(Taxon_Upham_style, cov = A))) + cumulative()

# use all linear measurements and phylo to estimate the missing value
imp_mod <- bf(Ipl | mi() ~ log_Mass + Sl + Sh + 
       Hl + Hsw + Hdw + Uol + Ul + Rl + 
       Fl + Fsw + Fdw + Tl + Tmw + 
       (1|gr(Taxon_Upham_style, cov = A))) + gaussian()

m_form <- ord_mod + imp_mod + set_rescor(FALSE)
```

####Prior  

```{r}
p1 <- get_prior(ord_mod + imp_mod + set_rescor(FALSE),
  data2 = list(A = A),
           data = dat) %>% 
  mutate(
    prior = case_when(
      class == "b"  ~ "normal(0, 1)",
      class == "sd" ~ "normal(0, 1)",
      class == "Intercept" ~ "normal(0, 1)",
      class == "sigma" ~ "normal(0, 0.5)",
      TRUE ~ prior
      )
  )
```

####Test Fit  

```{r message = FALSE, warning=FALSE, results = 'hide'}
tictoc::tic()

mm <- brm(ord_mod + imp_mod + set_rescor(FALSE),
          data2 = list(A = A),
          data = dat, 
          refresh = 0, 
          cores = 4,
          chains = 2,
          #iter = 500,
          prior = p1)

tictoc::toc()
```

```{r}
mm
```


```{r}
plot(conditional_effects(mm, effects = "Ipl", resp = "LocOrd2", categorical = TRUE, prob = 0.8), plot=F, points = T)[[1]] +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal)+ ylim(0,1) #+ xlim(NA, 4)

tt2 <- read_rds(here("Data","ordinal2_lm_models.Rds"))

plot(conditional_effects(tt2$Ipl,  categorical = TRUE, prob = 0.8), plot=F, points = T)[[1]] +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal)+ ylim(0,1) #+ xlim(NA, 4)


```

## Test 2: 15%


**Pppl** or Proximal Pes phalanx length -> roughly 15% missing data

#### Formula:  
 
```{r}
ord_mod <-  
  bf(Loc_Ord2 ~ mi(Pppl) + log_Mass + 
       (1 | Genus_species) +  
       (1|gr(Taxon_Upham_style, cov = A))) + cumulative()

# use all linear measurements and phylo to estimate the missing value
imp_mod <- bf(Pppl | mi() ~ log_Mass + Sl + Sh + 
       Hl + Hsw + Hdw + Uol + Ul + Rl + 
       Fl + Fsw + Fdw + Tl + Tmw + 
       (1|gr(Taxon_Upham_style, cov = A))) + gaussian()

m_form <- ord_mod + imp_mod + set_rescor(FALSE)
```

####Prior  

```{r}
p1 <- get_prior(ord_mod + imp_mod + set_rescor(FALSE),
  data2 = list(A = A),
           data = dat) %>% 
  mutate(
    prior = case_when(
      class == "b"  ~ "normal(0, 1)",
      class == "sd" ~ "normal(0, 1)",
      class == "Intercept" ~ "normal(0, 1)",
      class == "sigma" ~ "normal(0, 0.5)",
      TRUE ~ prior
      )
  )
```

####Test Fit  

```{r message = FALSE, warning=FALSE, results = 'hide'}
tictoc::tic()

mm2 <- brm(ord_mod + imp_mod + set_rescor(FALSE),
          data2 = list(A = A),
          data = dat, 
          refresh = 0, 
          cores = 4,
          chains = 2,
          #iter = 500,
          prior = p1)

tictoc::toc()
```

```{r}
mm2
```


```{r}
plot(conditional_effects(mm2, effects = "Pppl", resp = "LocOrd2", categorical = TRUE, prob = 0.8), plot=F, points = T)[[1]] +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal)+ ylim(0,1) #+ xlim(NA, 4)

tt2 <- read_rds(here("Data","ordinal2_lm_models.Rds"))

plot(conditional_effects(tt2$Pppl,  categorical = TRUE, prob = 0.8), plot=F, points = T)[[1]] +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal)+ ylim(0,1) #+ xlim(NA, 4)


```

## Test 2.2: No Phylo in Estimate

Compare the platypus estimates - is the uncertainty in the missing values in the platipuses dies to phylo or not?

I can also see how much the phylo in the missing values adds to the model runtime. Last iteration of the mm2 was 372.1 seconds for chain 1 and 438.3 for chain 2 

Looks like excluding the phylo drastically decreses the runtime to 90sec & 114 seconds!

#### Formula:  
 
```{r}
ord_mod <-  
  bf(Loc_Ord2 ~ mi(Pppl) + log_Mass + 
       (1 | Genus_species) +  
       (1|gr(Taxon_Upham_style, cov = A))) + cumulative()

# use all linear measurements and phylo to estimate the missing value
imp_mod2 <- bf(Pppl | mi() ~ log_Mass + Sl + Sh + 
       Hl + Hsw + Hdw + Uol + Ul + Rl + 
       Fl + Fsw + Fdw + Tl + Tmw ) + gaussian()

m_form <- ord_mod + imp_mod2 + set_rescor(FALSE)
```

####Prior  

```{r}
p1 <- get_prior(ord_mod + imp_mod2 + set_rescor(FALSE),
  data2 = list(A = A),
           data = dat) %>% 
  mutate(
    prior = case_when(
      class == "b"  ~ "normal(0, 1)",
      class == "sd" ~ "normal(0, 1)",
      class == "Intercept" ~ "normal(0, 1)",
      class == "sigma" ~ "normal(0, 0.5)",
      TRUE ~ prior
      )
  )
```

####Test Fit  

```{r message = FALSE, warning=FALSE, results = 'hide'}
tictoc::tic()

mm2.2 <- brm(ord_mod + imp_mod2 + set_rescor(FALSE),
          data2 = list(A = A),
          data = dat, 
          refresh = 0, 
          cores = 4,
          chains = 2,
          #iter = 500,
          prior = p1)

tictoc::toc()
```


## Test 3: 2%


**Ppl** or Proximal phalanx length -> roughly 15% missing data

#### Formula:  
This is complicated because I have to estimate the missing values with a gaussian model, then estimate the ordinal model. See post #3 [here:](https://discourse.mc-stan.org/t/error-argument-mi-is-not-supported-for-family-bernoulli-logit/7587/3)

I assume these models are going to take a while. My poor computer has started running the fan whenever I run 4 cores. 
```{r}
ord_mod <-  
  bf(Loc_Ord2 ~ mi(Ppl) + log_Mass + 
       (1 | Genus_species) +  
       (1|gr(Taxon_Upham_style, cov = A))) + cumulative()

# use all linear measurements and phylo to estimate the missing value
imp_mod <- bf(Ppl | mi() ~ log_Mass + Sl + Sh + 
       Hl + Hsw + Hdw + Uol + Ul + Rl + 
       Fl + Fsw + Fdw + Tl + Tmw + 
       (1|gr(Taxon_Upham_style, cov = A))) + gaussian()

m_form <- ord_mod + imp_mod + set_rescor(FALSE)
```

####Prior  

```{r}
p1 <- get_prior(ord_mod + imp_mod + set_rescor(FALSE),
  data2 = list(A = A),
           data = dat) %>% 
  mutate(
    prior = case_when(
      class == "b"  ~ "normal(0, 1)",
      class == "sd" ~ "normal(0, 1)",
      class == "Intercept" ~ "normal(0, 1)",
      class == "sigma" ~ "normal(0, 0.5)",
      TRUE ~ prior
      )
  )
```

####Test Fit  

```{r message = FALSE, warning=FALSE, results = 'hide'}
tictoc::tic()

mm3 <- brm(ord_mod + imp_mod + set_rescor(FALSE),
          data2 = list(A = A),
          data = dat, 
          refresh = 0, 
          cores = 4,
          chains = 2,
          #iter = 500,
          prior = p1)

tictoc::toc()
```

```{r}
mm3
```


```{r}
plot(conditional_effects(mm3, effects = "Ppl", resp = "LocOrd2", categorical = TRUE, prob = 0.8), plot=F, points = T)[[1]] +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal)+ ylim(0,1) #+ xlim(NA, 4)

tt2 <- read_rds(here("Data","ordinal2_lm_models.Rds"))

plot(conditional_effects(tt2$Ppl,  categorical = TRUE, prob = 0.8), plot=F, points = T)[[1]] +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal)+ ylim(0,1) #+ xlim(NA, 4)


```

#### View Estimates

```{r}
plotpreds <- function(mod){
  dat %>% 
  mutate(row=row_number()) %>% 
  left_join(
    posterior_summary({{mod}}, probs = c(0.1, 0.9)) %>% 
      data.frame() %>% 
      rownames_to_column("term") %>% 
      filter(str_detect(term, "Ymi")) %>% 
      mutate(row = str_extract(term, "(\\d)+") %>% as.integer()),
    by = "row"
  ) %>% 
  drop_na(term) %>% 
  select(Genus_species, Estimate, Q10, Q90) %>% 
  ggplot(aes(y = Genus_species)) +
  geom_pointrange(aes(x = Estimate, xmin = Q10, xmax = Q90)) 
}
```


This is really cool. 
in mm2.2, without phylo, the uncertainty around the pes ppl is the same for each species. 
Including the phylo, in mm2, the uncertainty is very different! Specifically monotremes have massive uncertainty. 
```{r}
plotpreds(mm)
plotpreds(mm2) + xlim(-2,3)
plotpreds(mm2.2) + xlim(-2,3)
plotpreds(mm3)
```

## Test 4 -Model with No Missing Values?

**Hl** - no missing data

SO this definitely doesn't work. 

I will need to run the missing models seperate from the non-missing models. That should be fine. 

#### Formula:  

```{r}
ord_mod <-  
  bf(Loc_Ord2 ~ mi(Hl) + log_Mass + 
       (1 | Genus_species) +  
       (1|gr(Taxon_Upham_style, cov = A))) + cumulative()

# use all linear measurements and phylo to estimate the missing value
imp_mod <- bf(Hl | mi() ~ log_Mass + Sl + Sh + 
       Hl + Hsw + Hdw + Uol + Ul + Rl + 
       Fl + Fsw + Fdw + Tl + Tmw + 
       (1|gr(Taxon_Upham_style, cov = A))) + gaussian()

m_form <- ord_mod + imp_mod + set_rescor(FALSE)
```

####Prior  

```{r}
p1 <- get_prior(ord_mod + imp_mod + set_rescor(FALSE),
  data2 = list(A = A),
           data = dat) %>% 
  mutate(
    prior = case_when(
      class == "b"  ~ "normal(0, 1)",
      class == "sd" ~ "normal(0, 1)",
      class == "Intercept" ~ "normal(0, 1)",
      class == "sigma" ~ "normal(0, 0.5)",
      TRUE ~ prior
      )
  )
```

####Test Fit  

```{r message = FALSE, warning=FALSE, results = 'hide'}
tictoc::tic()

mm4 <- brm(ord_mod + imp_mod + set_rescor(FALSE),
          data2 = list(A = A),
          data = dat, 
          refresh = 0, 
          cores = 4,
          chains = 2,
          #iter = 500,
          prior = p1)

tictoc::toc()
```

```{r}
mm4
```


```{r}
plot(conditional_effects(mm4, effects = "Hl", resp = "LocOrd2", categorical = TRUE, prob = 0.8), plot=F, points = T)[[1]] +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal)+ ylim(0,1) #+ xlim(NA, 4)

tt2 <- read_rds(here("Data","ordinal2_lm_models.Rds"))

plot(conditional_effects(tt2$Hl,  categorical = TRUE, prob = 0.8), plot=F, points = T)[[1]] +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal)+ ylim(0,1) #+ xlim(NA, 4)


```


```{r}
plotpreds(mm4)
```

#################
################################
####################################

# Fit Models 


Looping over all of the variables to see which ones do a good job predicting the binary tree vs. no-tree categorization

#### Get Prior

```{r message = FALSE, warning=FALSE, results = 'hide'}

p1 <- get_prior(Loc_Ord2 ~ Sl + log_Mass + (1 | Genus_species) +  (1|gr(Taxon_Upham_style, cov = A)),
  data2 = list(A = A),
           family = cumulative(),
           data = dat) %>% 
    mutate(
      prior = case_when(
        class == "b"  ~ "normal(0, 1)",
        class == "sd" ~ "normal(0, 1)",
        class == "Intercept" ~ "normal(0, 1)",
        TRUE ~ prior
      )
    )
```


```{r message = FALSE, warning=FALSE,  cache=TRUE, results = 'hide'}
#initial fit
mm <- brm(Loc_Ord2 ~ Sl + log_Mass + (1 | Genus_species) +  (1|gr(Taxon_Upham_style, cov = A)),
          data2 = list(A = A),
          family = cumulative(),
          data = dat, refresh = 0, cores = 4,
          prior = p1)
```



```{r}
pal = c('#66a61e', '#7570b3', '#62361B',  '#e6ab02')
cols = c("#7570b3" ,  "#85D4E3" , "#0D7E9A",'#f5f5cb', '#c7e6d4', '#8cd2cd', '#55c3cf', '#3fa4b0', '#187389','#f48a1a', '#e6ab02', '#66a61e', '#85D4E3', '#0D7E9A', '#7570b3','#f6d03d', '#fe7b30', '#ef4a27', '#f384f8', '#625afc', '#0d57ff', '#47a7ff','#5771ff', '#6bae9e', '#31c1bb', '#7af1e1', '#d5e1af', '#f48130','#C60C30', '#00A1DE', '#62361B', '#009B3A', '#f9581c', '#522398', '#E27EA6', '#F9E300', '#565A5C')
```

```{r}
plot(conditional_effects(mm, categorical = TRUE), plot = F)[[1]] +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal)
```

#### Log Mass Loop

```{r  message = FALSE, warning=FALSE, results = 'hide', cache = TRUE}
varis <- colnames(dat)[19:95]

list_o2_lm <- vector(mode ="list")

for(i in varis){
  list_o2_lm[[i]]<- update(mm,
                         formula=(paste0("Loc_Ord2 ~", i, "+log_Mass+(1|Genus_species)+(1|gr(Taxon_Upham_style,cov = A))")),
                         family = cumulative(),
                         newdata=dat,
                         refresh = 0,
                         cores = 4,
                         data2 = list(A = A),
                         prior = p1
                         ) 
}

list_o2_lm %>% write_rds(here("Data","ordinal2_lm_models.Rds"))
```


#### Geometric Mean Loop

```{r  message = FALSE, warning=FALSE, results = 'hide', cache = TRUE}
varis <- colnames(dat)[19:95]

list_o2_gm <- vector(mode ="list")

for(i in varis){
  list_o2_gm[[i]]<- update(mm,
                         formula=(paste0("Loc_Ord2 ~", i, "+gm+(1|Genus_species)+(1|gr(Taxon_Upham_style,cov = A))")),
                         family = cumulative(),
                         newdata=dat,
                         refresh = 0,
                         cores = 4,
                         data2 = list(A = A),
                         prior = p1
                         ) 
}

list_o2_gm %>% write_rds(here("Data","ordinal2_gm_models.Rds"))
```


## Model tuning 


I'm not sure how to help the divergent transitions. They seem to appear with the intraspecific variation and the phylogenetic variation. 


```{r message = FALSE}
source("Dirichlet_Prior.R")

ps1 <- get_prior(Loc_Ord2 ~ Ppl + log_Mass + (1 | Genus_species) +  (1|gr(Taxon_Upham_style, cov = A)), data2 = list(A = A),family = cumulative(), data = dat) %>%  mutate(prior = case_when(
  class == "b"  ~ "normal(0,1)",
  class == "sd" ~ "normal(0, 1)",
  class == "Intercept" ~ "student_t(2,0,2)",
  TRUE ~ prior ) )

ps2 <- ps1 %>%  mutate(prior = case_when(
  class == "b"  ~ "student_t(3,0,1)",
  class == "sd" ~ "normal(0, 1)",
  class == "Intercept" ~ "student_t(1,0,2)",
  TRUE ~ prior ) )

ps3 <- ps1 %>%  mutate(prior = case_when(
  class == "b"  ~ "normal(0, 1)",
  class == "sd" ~ "normal(0, 1)",
  class == "Intercept" ~ "normal(0, 1)",
  TRUE ~ prior ) )

ps4 =  c(set_prior("induced_dirichlet(rep_vector(1, nthres+1),0", class = "Intercept"),
          set_prior("student_t(2,0,2)", class = "sd"),
          set_prior("normal(0,1)", class = "b"))

ps5 =  c(set_prior("induced_dirichlet(rep_vector(1, nthres+1),0", class = "Intercept"),
          set_prior("normal(0,1)", class = "sd"),
          set_prior("normal(0,1)", class = "b"))
```


```{r warning = FALSE}

ms_1 <- brm( Loc_Ord2 ~ Ppl + log_Mass + (1|Genus_species)+ (1|gr(Taxon_Upham_style,cov = A)), family = cumulative(), data=dat, refresh = 0, cores = 4, data2 = list(A = A), prior = ps1)

ms_2 <- brm( Loc_Ord2 ~Ppl +  + log_Mass +(1|Genus_species)+ (1|gr(Taxon_Upham_style,cov = A)), family = cumulative(), data=dat, refresh = 0, cores = 4, data2 = list(A = A), prior = ps2)

ms_3 <- brm( Loc_Ord2 ~ Ppl +  log_Mass +  (1|Genus_species)+ (1|gr(Taxon_Upham_style,cov = A)), family = cumulative(), data=dat, refresh = 0, cores = 4, data2 = list(A = A), prior = ps3)

ms_4 <- brm( Loc_Ord2 ~ Ppl +  log_Mass +  (1|Genus_species)+ (1|gr(Taxon_Upham_style,cov = A)), family = cumulative(), data=dat, refresh = 0, cores = 4, data2 = list(A = A), prior = ps4, stanvars = dirichlet_prior_stanvar)

ms_5 <- brm( Loc_Ord2 ~ Ppl +  log_Mass +  (1|Genus_species)+ (1|gr(Taxon_Upham_style,cov = A)), family = cumulative(), data=dat, refresh = 0, cores = 4, data2 = list(A = A), prior = ps5, stanvars = dirichlet_prior_stanvar)
```


```{r}
loo(ms_1, ms_2, ms_3, ms_4, ms_5)
```

```{r}
plot(conditional_effects(ms_4, categorical = TRUE), plot = F)[[1]] +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal)

plot(conditional_effects(ms_3, categorical = TRUE), plot = F)[[1]] +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal)

plot(ms_4, N=3, ask=F)
```

## Probit vs. logit
```{r warning = F}
ml <- brm(Loc_Ord2 ~ Ppl + log_Mass + (1 | Genus_species) +  (1|gr(Taxon_Upham_style, cov = A)),
          data2 = list(A = A),
          family = cumulative(link = "logit"),
          data = dat, refresh = 0, cores = 4,
          prior = c(set_prior("normal(0,1)", class = "sd"),
                      set_prior("normal(0,1)",  class = "b")))

mp <- brm(Loc_Ord2 ~ Ppl + log_Mass + (1 | Genus_species) +  (1|gr(Taxon_Upham_style, cov = A)),
          data2 = list(A = A),
          family = cumulative(link = "probit"),
          data = dat, refresh = 0, cores = 4,
          prior = c(set_prior("normal(0,1)", class = "sd"),
                      set_prior("normal(0,1)",  class = "b")))
```

```{r}
loo(ml, mp)
```

```{r}
pp_check(ml, type = 'bars', ndraws = 1000)
pp_check(mp, type = 'bars', ndraws = 1000)
```


## ANOVA

```{r warning = FALSE, message=FALSE}
anv1 <- brm( Ppl ~ 0 + Loc_Ord2 +  log_Mass +  (1|Genus_species)+ (1|gr(Taxon_Upham_style,cov = A)), family = gaussian(), data=dat, refresh = 0, cores = 4, data2 = list(A = A), 
             prior = c(set_prior("normal(0,1)", class = "sd"),
          set_prior("normal(0,1)", class = "b")))

anv2 <- brm(bf(Uol ~ 0 + Loc_Ord2 +  log_Mass + (1|Genus_species)+ (1|gr(Taxon_Upham_style,cov = A)),
               sigma ~ 0 + Loc_Ord2),
            family = gaussian(), 
            data=dat, refresh = 0, 
            cores = 4, data2 = list(A = A), 
            prior = c(set_prior("normal(0,1)", 
                                class = "sd"),
                      set_prior("normal(0,1)", 
                                class = "b")))
```

```{r}
as_draws_df(anv1) %>% 
  select(1:4) %>% 
  gather(var, val) %>% 
  ggplot(aes(x = val, y = var)) + 
  stat_halfeye(.width = c(.66, .89)) + 
  xlim(-1.25, 1)

as_draws_df(anv2) %>% 
  select(1:4) %>% 
  gather(var, val) %>% 
  ggplot(aes(x = val, y = var)) + 
  stat_halfeye(.width = c(.66, .89)) + 
  xlim(-1.25, 1)

as_draws_df(anv1) %>% 
  select(1:4) %>% 
  mutate(dif_A_Sc = b_Loc_Ord2A - b_Loc_Ord2Sc,
         dif_A_T = b_Loc_Ord2A - b_Loc_Ord2T,
         dif_A_B = b_Loc_Ord2A - b_Loc_Ord2B) %>% 
  select(5:7) %>% 
  gather(var, val) %>% 
  ggplot(aes(x = val, y = var)) + 
  geom_halfeyeh(.width = c(.66, .89))

as_draws_df(anv2) %>% 
  select(1:4) %>% 
  mutate(dif_A_Sc = b_Loc_Ord2A - b_Loc_Ord2Sc,
         dif_A_T = b_Loc_Ord2A - b_Loc_Ord2T,
         dif_A_B = b_Loc_Ord2A - b_Loc_Ord2B) %>% 
  select(5:7) %>% 
  gather(var, val) %>% 
  ggplot(aes(x = val, y = var)) + 
  stat_halfeye(.width = c(.66, .89))
  
  
```


